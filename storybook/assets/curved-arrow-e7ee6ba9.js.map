{"version":3,"file":"curved-arrow-e7ee6ba9.js","sources":["../../src/elements/base/drivebases/curved-arrow.ts"],"sourcesContent":["/**\r\n * Copyright (c) 2017-2018 FIRST\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of FIRST nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY FIRST AND CONTRIBUTORS \"AS IS\" AND ANY\r\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY NONINFRINGEMENT AND FITNESS FOR A PARTICULAR\r\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FIRST OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * A utility class for generating curved arrows. The generated arrows follow a <i>circular</i>, rather than\r\n * <i>elliptical</i>, path. The heads of the arrows are always the same isosceles triangle with the length of the base\r\n * equalling the height of the triangle; this works out to be (approximately) a 63-63-54 triangle.\r\n */\r\n\r\ntype Point = { x: number; y: number };\r\n\r\nfunction toDegrees(radians: number) {\r\n  return (radians * 180) / Math.PI;\r\n}\r\n\r\nfunction line(x1: number, y1: number, x2: number, y2: number) {\r\n  return `<line x1=\"${x1}\" y1=\"${y1}\" x2=\"${x2}\" y2=\"${y2}\" />`;\r\n}\r\n\r\nfunction triangle(point1: Point, point2: Point, point3: Point) {\r\n  return `<polygon \r\n            points=\"${point1.x},${point1.y} ${point2.x},${point2.y} ${point3.x},${point3.y}\" />`;\r\n}\r\n\r\n// https://stackoverflow.com/questions/5736398/how-to-calculate-the-svg-path-for-an-arc-of-a-circle\r\nfunction polarToCartesian(\r\n  centerX: number,\r\n  centerY: number,\r\n  radius: number,\r\n  angleInDegrees: number\r\n) {\r\n  const angleInRadians = (angleInDegrees * Math.PI) / 180.0;\r\n\r\n  return {\r\n    x: centerX + radius * Math.cos(angleInRadians),\r\n    y: centerY - radius * Math.sin(angleInRadians),\r\n  };\r\n}\r\n\r\nfunction describeArc(\r\n  x: number,\r\n  y: number,\r\n  radius: number,\r\n  startAngle: number,\r\n  endAngle: number\r\n) {\r\n  const start = polarToCartesian(x, y, radius, endAngle);\r\n  const end = polarToCartesian(x, y, radius, startAngle);\r\n\r\n  const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';\r\n  const sweepFlag = endAngle > startAngle ? 1 : 0;\r\n\r\n  const d = [\r\n    'M',\r\n    start.x,\r\n    start.y,\r\n    'A',\r\n    radius,\r\n    radius,\r\n    0,\r\n    largeArcFlag,\r\n    sweepFlag,\r\n    end.x,\r\n    end.y,\r\n  ].join(' ');\r\n\r\n  return d;\r\n}\r\n\r\nfunction arc(\r\n  x: number,\r\n  y: number,\r\n  radius: number,\r\n  startAngle: number,\r\n  endAngle: number\r\n) {\r\n  return `<path d=\"${describeArc(x, y, radius, startAngle, endAngle)}\"/>`;\r\n}\r\n\r\n/**\r\n * Generates the head of a straight arrow.\r\n */\r\nexport function straightHead(\r\n  startAngle: number,\r\n  size: number,\r\n  xOffset: number,\r\n  bodyLength: number\r\n): string {\r\n  const base = size / 2;\r\n\r\n  // Unit vector to the end of the shaft\r\n  const ux = Math.cos(startAngle);\r\n  const uy = Math.sin(startAngle);\r\n\r\n  // Unit vector to the center of the base of the head\r\n  const bx = Math.cos(startAngle + Math.PI / 2) * base; // ==  Math.sin(startAngle)\r\n  const by = Math.sin(startAngle + Math.PI / 2) * base; // == -Math.cos(startAngle)\r\n\r\n  const basePoint1 = {\r\n    x: ux * bodyLength - bx + xOffset,\r\n    y: uy * bodyLength - by,\r\n  };\r\n\r\n  const basePoint2 = {\r\n    x: ux * bodyLength + bx + xOffset,\r\n    y: uy * bodyLength + by,\r\n  };\r\n\r\n  const tip = {\r\n    x: ux * (size + bodyLength) + xOffset,\r\n    y: uy * (size + bodyLength),\r\n  };\r\n\r\n  return triangle(basePoint1, basePoint2, tip);\r\n}\r\n\r\n/**\r\n * Creates a straight arrow, which is just a curved arrow with an infinite radius.\r\n *\r\n * @param length   the length of the arrow\r\n * @param angle    the angle of the arrow, in radians\r\n * @param xOffset  how much to offset the arrow along the X-axis\r\n * @param headSize the length of the head of the arrow\r\n */\r\nexport function createStraight(\r\n  length: number,\r\n  angle: number,\r\n  xOffset: number,\r\n  headSize: number\r\n): string {\r\n  const x = Math.cos(angle) * length;\r\n  const y = Math.sin(angle) * length;\r\n  const body = line(xOffset, 0, x + xOffset, y);\r\n  const head = straightHead(angle, headSize, xOffset, length);\r\n  return body + head;\r\n}\r\n\r\n/**\r\n * Generates the body arc of the arrow.\r\n *\r\n * @param startAngle the starting angle of the arc, in radians\r\n * @param radius     the radius of the arc\r\n * @param length     the length of the arc, in the same unit as {@code radius}\r\n * @param xOffset    how much to offset the arc along the X-axis\r\n */\r\nexport function makeBody(\r\n  startAngle: number,\r\n  radius: number,\r\n  length: number,\r\n  xOffset: number\r\n) {\r\n  const angRad = length / radius; // Isn't math nice?\r\n  const angle = toDegrees(angRad);\r\n  return arc(\r\n    xOffset,\r\n    0,\r\n    radius,\r\n    toDegrees(startAngle),\r\n    toDegrees(startAngle) - angle\r\n  );\r\n}\r\n\r\n/**\r\n * Generates the head of a curved arrow.\r\n *\r\n * @param startAngle the starting angle of the arc, in radians\r\n * @param size       the length of the arrow head\r\n * @param arcRadius  the radius of the arc of the arrow\r\n * @param arcLength  the length of the arc of the arrow\r\n */\r\nexport function curvedHead(\r\n  startAngle: number,\r\n  size: number,\r\n  arcRadius: number,\r\n  xOffset: number,\r\n  arcLength: number\r\n) {\r\n  // Half the length of the triangle\r\n  const base = size / 2;\r\n\r\n  // Angle to the base of the arrow\r\n  const angleToBase = arcLength / arcRadius - startAngle;\r\n\r\n  // Radius to the tip of the arrow. Simple Pythagorean theorem\r\n  const tipRadius = Math.sqrt(size * size + arcRadius * arcRadius);\r\n\r\n  // Angle to the tip of the arrow\r\n  // If the length is negative, the tip is closer to the start of the arc and therefore needs to be\r\n  // (arcLength - size) / arcRadius - startAngle\r\n  // If the length is positive, the tip is further from the start of the arc is is therefore\r\n  // (arcLength + size) / arcRadius - startAngle\r\n  // These are combined into a single calculating by multiplying `size` by the sign of the arc length\r\n  const angleToTip =\r\n    (arcLength + size * Math.sign(arcLength)) / arcRadius - startAngle;\r\n\r\n  const ux = Math.cos(angleToBase); // unit X in (-1, 1)\r\n  const uy = Math.sin(angleToBase); // unit Y in (-1, 1)\r\n\r\n  // Note there's no \"top\" or \"bottom\" point, since it depends on the sign of uy\r\n  const basePoint1 = {\r\n    x: (arcRadius + base) * ux + xOffset,\r\n    y: (arcRadius + base) * uy,\r\n  };\r\n\r\n  const basePoint2 = {\r\n    x: (arcRadius - base) * ux + xOffset,\r\n    y: (arcRadius - base) * uy,\r\n  };\r\n\r\n  const tipPoint = {\r\n    x: tipRadius * Math.cos(angleToTip) + xOffset,\r\n    y: tipRadius * Math.sin(angleToTip),\r\n  };\r\n\r\n  return triangle(basePoint1, tipPoint, basePoint2);\r\n}\r\n\r\n/**\r\n * Creates a new curved arrow.\r\n *\r\n * @param startAngle the starting angle of the arc, in radians\r\n * @param radius     the radius of the arrow. Must be non-negative.\r\n * @param length     the length of the arrow, in the same units as {@code radius}\r\n * @param xOffset    how much to offset the arc along the X-axis\r\n * @param headSize   the length of the head of the arrow\r\n *\r\n * @return a curved arrow shape\r\n *\r\n * @throws IllegalArgumentException if {@code radius} or {@code headSize} are negative\r\n */\r\nexport function create(\r\n  startAngle: number,\r\n  radius: number,\r\n  length: number,\r\n  xOffset: number,\r\n  headSize: number\r\n) {\r\n  if (radius < 0) {\r\n    throw new Error(`Radius cannot be negative. Given: ${radius}`);\r\n  }\r\n  if (headSize < 0) {\r\n    throw new Error(\r\n      `The size of the arrowhead cannot be negative. Given: ${headSize}`\r\n    );\r\n  }\r\n  if (radius === Infinity) {\r\n    // infinite radius = straight\r\n    return createStraight(length, startAngle, xOffset, headSize);\r\n  }\r\n\r\n  return (\r\n    makeBody(startAngle, radius, length, xOffset) +\r\n    curvedHead(startAngle, headSize, radius, xOffset, length)\r\n  );\r\n}\r\n\r\n/**\r\n * Creates a new curved arrow. This is equivalent to calling\r\n * {@link #create create(startAngle, radius, radius * sweepAngle, xOffset, headSize)}.\r\n *\r\n * @param startAngle the starting angle of the arc, in radians\r\n * @param radius     the radius of the arc\r\n * @param sweepAngle the sweep of the arc, in radians\r\n * @param xOffset    how much to offset the arc along the X-axis\r\n * @param headSize   the length of the head of the arrow\r\n *\r\n * @throws IllegalArgumentException if {@code radius} or {@code headSize} are negative\r\n */\r\nexport function createPolar(\r\n  startAngle: number,\r\n  radius: number,\r\n  sweepAngle: number,\r\n  xOffset: number,\r\n  headSize: number\r\n) {\r\n  return create(startAngle, radius, radius * sweepAngle, xOffset, headSize);\r\n}\r\n"],"names":["toDegrees","radians","line","x1","y1","x2","y2","triangle","point1","point2","point3","polarToCartesian","centerX","centerY","radius","angleInDegrees","angleInRadians","describeArc","x","y","startAngle","endAngle","start","end","largeArcFlag","sweepFlag","arc","straightHead","size","xOffset","bodyLength","base","ux","uy","bx","by","basePoint1","basePoint2","tip","createStraight","length","angle","headSize","body","head","makeBody","angRad","curvedHead","arcRadius","arcLength","angleToBase","tipRadius","angleToTip","tipPoint","create","createPolar","sweepAngle"],"mappings":"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"}